{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"analisis-python/importing-cleaning-data/introduccion/archivos-planos/","title":"Introducci\u00f3n a Importaci\u00f3n de Datos","text":""},{"location":"analisis-python/importing-cleaning-data/introduccion/archivos-planos/#archivos-planos","title":"Archivos Planos","text":"<p>Se abordar\u00e1 los temas de la importaci\u00f3n de datos sin formato, ya sea un <code>.txt</code> o <code>.csv</code></p> Archivos sin formato `.txt`<pre><code>with open(\"archivo.txt\", \"r\") as file:\n    print(file.read())\n</code></pre> <p>Mediante la cl\u00e1usula <code>with</code> podemos abrir un archivo sin formato como los <code>.txt</code>, indicando si queremos leer <code>'r'</code> o escribir <code>'w'</code>, sin tener que preocuparnos en tener que cerrar <code>.close()</code>.</p> Leer con `numpy`<pre><code>np.loadtxt(file, delimiter=None, skiprows=0, encoding=None, dtype=float)\n</code></pre> <p>Si nuestro archivo son datos de solo tipo num\u00e9rico, se puede utilizar numpy o si queremos trabajar con texto se usa <code>dtype=str</code>.</p> <p>Si queremos omitir el encabezado, se usa <code>skiprows=1</code>. En caso que solo querramos extraer la columna 1 y 3, se usa <code>usecols=[0, 2]</code>.</p> <p>Si el delimitador es la tabulaci\u00f3n, entonces se usa <code>delimiter='\\t'</code></p> Leer con `.pandas`<pre><code>pd.read_csv(file, *, \n            delimiter=None,\n            header='infer', \n            skiprows=None, \n            na_values=None, \n            encoding=None, \n            date_parser=None,\n            comment=None\n            )\n</code></pre> <ul> <li><code>delimiter=None</code>: Detecta autom\u00e1ticamente el delimitador.</li> <li><code>header='infer'</code>: Infiere que la primera fila es el encabezado, si no tiene se coloca <code>None</code>.</li> <li><code>skiprows=None</code>: Se indica si queremos saltear las N primeras filas. </li> <li><code>na_values=None</code>: Se indica mediante una lista los valores que ser\u00e1n reemplazados por <code>NaN</code>.</li> <li><code>encoding=utf-8</code>: Se indica el tipo de encoding para poder leer, pueder ser el <code>latin-1</code> y otros.</li> <li><code>date_parser</code>=None`: Si hay una columna que es de tipo fecha, se indica aqu\u00ed con el nombre de la columna.</li> <li><code>comment=None</code>: Se indica el caracter que da entrada a los comentarios <code>#</code>.</li> </ul>"},{"location":"cloud/azure/introduccion/","title":"Introduccion","text":""},{"location":"cloud/azure/introduccion/#el-poder-del-cloud","title":"El poder del Cloud","text":"<p>Los servicios del Cloud tiene 3 enfoques principales, estas son:</p> <ul> <li>Almacenamiento: Gardan archivos o datos.</li> <li>Base de Datos: Se centra en almacenar los datos relacionales.</li> <li>C\u00f3mputo: Son los componentes de c\u00f3mputo, procesador, memor\u00eda, GPU, etc.</li> </ul> <p>La ventaja del Cloud son:</p> <ul> <li>Virtualizaci\u00f3n</li> <li>Escalabilidad</li> <li>Costos</li> <li>Velocidad</li> <li>Rendimiento</li> </ul>"},{"location":"cloud/azure/introduccion/#virtualizacion","title":"Virtualizaci\u00f3n","text":"<p>La virtualizaci\u00f3n es el poder obtener una o varias m\u00e1squinas virtuales (VM) a partir de un sistema f\u00edsico. Estos sistemas f\u00edsicos puede ser brindados por un servicio de Cloud o de forma local (en nuestra propia PC).</p> <p>La vistualizaci\u00f3n se logra mediante un hipervisor (hypervisor), un software que act\u00faa como una capa entre el hardware f\u00edsico y las VMs. Existen dos tipos de hipervisores:</p> <ol> <li> <p>Hipervisor tipo 1 (bare-metal): Se instala directamente sobre el hardware f\u00edsico. Es el que nos brinda los proveedores de la nube (AWS, Azure, GCP, etc.).</p> </li> <li> <p>Hipervisor tipo 2 (hosted): Se instala sobre el sistema operativo existente. Los que usan este tipo de hipervisor son los programas como VirtualBox, VMware.</p> </li> </ol> Estructura de los tipos de Hipervisores Tipo 1 Tipo 2 Gestiona los recursos directamente desde el hardware f\u00edsico, mejor rendimiento. Compite por recursos con el sistema que lo hospeda, afecta el rendimiento. Menor latencia M\u00e1s f\u00e1cil de usar M\u00e1s seguro Ideal para pruebas y desarrollo"},{"location":"cloud/azure/introduccion/#escalabilidad","title":"Escalabilidad","text":"<p>La escalabiliadad es la capacidad de un sistema para ajustar sus recursos (CPU, RAM, almacenamiento, etc.) de acuerdo a las necesidades del usuario o a la carga de trabajo. Es la posibilidad de aumentar o disminuir las m\u00e1quinas virtuales o los recursos de estas.</p> <ul> <li> <p>Escala Vertical: Aumentar o disminuir los recursos de las m\u00e1quinas virtuales existentes (m\u00e1s CPU, m\u00e1s RAM, etc.)</p> </li> <li> <p>Escala Horizontal: Agregar o quitar m\u00e1quinas virtuales (instancias) para distribuir la carga de trabajo.</p> </li> </ul> Escalabilidad vertical y horizontal"},{"location":"cloud/azure/introduccion/#costos","title":"Costos","text":"<p>Es una de las caracter\u00edsticas principales de los servicios Cloud, solo se paga por los recursos utilizados, ahorrando en los costos por mantenimiento, instalaci\u00f3n, infraestructura local, etc. Sin embargo, esto no quita que para ciertos casos, a largo plazo la soluci\u00f3n on-premise resulte m\u00e1s rentable.   </p>"},{"location":"cloud/azure/introduccion/#velocidad","title":"Velocidad","text":"<p>Los recursos que se requiere son puesto a nuestra disposici\u00f3n de forma casi inmediata cuando es solicitado. No se pasa por ning\u00fana persona externa o una cola de espera.</p>"},{"location":"cloud/azure/introduccion/#rendimiento","title":"Rendimiento","text":"<p>Tomando en cuenta lo  anterior, obtenemos una mejor gesti\u00f3n de los recursos, accediendo a los componentes m\u00e1s actuales y mejores en un instante, redes de alto rendimiento que permite la transferencia de datos m\u00e1s r\u00e1pido, mayor seguridad en poder tener nuestros recursos en distintos data centers que nos ofrece la nube.</p>"},{"location":"cloud/azure/introduccion/#redundancia-y-alta-disponibilidad","title":"Redundancia y Alta Disponibilidad","text":"<p>Los datos y servicios en la nube est\u00e1n distribuidos en m\u00faltiples ubicaciones para garantizar que si un centro de datos falla, otro puede reemplazarlo. Nos garantiza que nuestras aplicaciones o datos est\u00e9n disponibles casi todo el tiempo, con m\u00ednimas interrupciones.</p>"},{"location":"cloud/azure/introduccion/#seguridad","title":"Seguridad","text":"<p>Ofrecen protocolos de seguridad avanzados, incluyendo cifrados, autentificaci\u00f3n multifactor, y firewalls para proteger los datos. Los proveedores de servicios Cloud, tienen equipos especializados en ciberseguridad para la protecci\u00f3n de los datos. No solo en ciberseguridad sino tambi\u00e9n en seguridad corporativa, teniendo los centro de datos en una estricta vigilancia.</p>"},{"location":"cloud/azure/introduccion/#modelos-de-servicios-cloud","title":"Modelos de servicios Cloud","text":"Modelos de Cloud <p>Existen tres modelos principales de servicio en la nube, cada uno con diferentes niveles de control, flexibilidad y responsabilidad para el usuario. Estos modelos son:</p>"},{"location":"cloud/azure/introduccion/#iaas-infrastructure-as-a-service","title":"IaaS (Infrastructure as a Service)","text":"<p>El proveedor de la nube ofrece los recursos de la infraestructura virtualizados (VM, almacenamiento y redes), es decir, nos ofrece las instancias de su infraestructura. Donde ellos son los responsable de su mantenimiento. Por nuestra parte, tenemos que gestionar las aplicaciones, el sistema operativo, el software.</p> <p>Ejemplos de estos son: AWS, Azure, GCP, etc.</p>"},{"location":"cloud/azure/introduccion/#paas-platform-as-a-service","title":"PaaS (Platform as a Service)","text":"<p>En este modelo nosotros solo tenemos que gestionar la aplicaci\u00f3n y los datos, por lo dem\u00e1s se encarga el proveedor. Es decir, el cliente solo se enfocar\u00eda en el desarrollo de la aplicaci\u00f3n (c\u00f3digo) y de la gesti\u00f3n de los datos, dejando al proveedor la gesti\u00f3nd el sistema operativo, infraestructura y dem\u00e1s.</p> <p>Ejemplos de estos son: Power Apps, Google App Engine, Azure App Services, AWS Elastic Beanstalk.</p>"},{"location":"cloud/azure/introduccion/#saas-software-as-a-service","title":"SaaS (Software as a Service)","text":"<p>Es el modelo de servicio m\u00e1s accesible para el usuario general. Proporciona aplicaciones completas a trav\u00e9s de la web que son gestionadas por el proveedor.</p> <p>Ejemplo de estos son: Notion, Gmail, Microsoft 365, SalesForce, etc.</p>"},{"location":"cloud/azure/introduccion/#faas-function-as-a-service-servelees","title":"FaaS (Function as a Service - Servelees)","text":"<p>Este modelo es conocido como sin servidor, el proveedor gestiona todos los aspectos de infraestructura y el usuario solo ejecuta funciones espec\u00edficas de c\u00f3digo. El c\u00f3digo se ejecuta en respuesta a eventos y es escalado autom\u00e1ticamente. Pagas por el tiempo que se ejecuta el c\u00f3digo</p> <p>Ejemplo de estos son: AWS Lambda, Azure Functions, Google Cloud Functions, Zapier.</p>"},{"location":"finanzas-python/","title":"FINANZAS","text":""},{"location":"finanzas-python/1-gestion-riesgo-portafolio/1-riesgo-retorno/","title":"Riesgo y Retorno","text":"","tags":["Python","Estad\u00edstica"]},{"location":"finanzas-python/1-gestion-riesgo-portafolio/1-riesgo-retorno/#riesgo-y-retorno-financiero","title":"Riesgo y Retorno Financiero","text":"<p>El Riesgo financiero es una medida de la incertidumbre de los rendimientos futuros, es decir, es la dispersi\u00f3n o varianza de los rendimientos.</p>","tags":["Python","Estad\u00edstica"]},{"location":"finanzas-python/1-gestion-riesgo-portafolio/1-riesgo-retorno/#rendimiento-discreto-rd","title":"Rendimiento Discreto (RD)","text":"<p>Es el cambio porcentual en el precio de un activo en un periodo determinado</p> \\[ \\begin{equation} \\bbox[3pt, border: 1pt solid #00adc3]{RD=\\frac{P_{final} - P_{inicial}}{P_{inicial}}} \\label{eq:rd} \\end{equation} \\] <p>Si queremos calcular el rendimiento total bimestral, teniendo el rendimiento por cada mes:</p> <ul> <li>\\(P_1=100\\%\\)</li> <li>\\(P_2=-50\\%\\)</li> </ul> <p>El primer pensamiento ser\u00eda que el rendimiento total es la suma de los rendimientos de los periodos, si es as\u00ed, entonces el rendimiento total ser\u00eda</p> \\[RD_{Total}=P_1+P_2=50\\%\\] <p>Si nuestro capital inicial es de \\(\\$/.100.00\\), entonces al final tendr\u00edamos \\(\\$/. 150.00\\).</p> <p>Para comprobar, vamos a calcular periodo por periodo, sabemos que,</p> \\[     RD=\\frac{P_{final} - P_{inicial}}{P_{inicial}} \\rightarrow P_{final}=(RD+1)*P_{inicial} \\] <ul> <li>Periodo 1: \\(P_{1}=(100\\%+1)*100 = \\$200.00\\)</li> <li>Periodo 2: \\(P_{2}=(-50\\%+1)*200 = \\$100.00\\)</li> </ul> <p>Como vemos, tenemos nuestro capital final (periodo 2) que indica que es \\(\\$100.00\\). Pero nuestro capital inicial es de \\(\\$100.00\\), entonces el rendimiento final no es del \\(50\\%\\) como se calcul\u00f3 anteriormente, sino que es del \\(0\\%\\). Nos podemos dar cuenta que el Rendimiento Discreto Total no es aditivo. Esto se debe a que el precio, monto o capital base cambia por cada periodo, por lo que la suma no es el correcto, es un c\u00e1lculo compuesto.</p> \\[ \\begin{equation} \\bbox[3pt, border: 1pt solid #00adc3]{RD_{Total}=(1+RD_1)(1+RD_2)(...) - 1 \\label{eq:rd-total}} \\end{equation} \\] <p>Calculando el Rendimiento Discreto Total \\(\\eqref{eq:rd-total}\\), mediante esta \u00faltima f\u00f3rmula:</p> \\[RD_{Total}=(1+100\\%)(1-50\\%) - 1 = 0\\%\\]","tags":["Python","Estad\u00edstica"]},{"location":"finanzas-python/1-gestion-riesgo-portafolio/1-riesgo-retorno/#rendimiento-logaritmico-rl","title":"Rendimiento Logar\u00edtmico (RL)","text":"<p>Es el logaritmo natural del cambio en el precio de un activo</p> \\[ \\begin{equation} \\bbox[3pt, border: 1pt solid #00adc3]{RL=\\ln(\\frac{P_{final}}{P_{inicial}})} \\label{eq:rl} \\end{equation} \\] <p>Supongamos que el Rendimiento Total es mediante la suma de los rendimientos de sus periodos, entonces</p> \\[RL_{Total}=\\ln(\\frac{P_{final}}{P_{intermedio}}) + \\ln(\\frac{P_{intermedio}}{P_{inicial}})\\] \\[RL_{Total}=\\ln(\\frac{P_{final}}{\\cancel{P_{intermedio}}}*\\frac{\\cancel{P_{intermedio}}}{P_{inicial}})\\] \\[\\therefore RL_{Total}=\\ln(\\frac{P_{final}}{P_{inicial}})\\] <p>Como vemos, s\u00ed tiene sentido, en este caso no est\u00e1 el problema con los precios, montos, capitales intermedios ya que esto se eliminan al ser sumados para obtener el Rendimiento Total.</p> <p>Tomando los valores del ejemplo anterior:</p> \\[RL_{Total}=\\ln(\\frac{200}{100}) + \\ln(\\frac{100}{200}) = 0.6931 - 0.6931 = 0\\%\\] <p>Entonces, sumando los rendimientos de los periodos nos arroja un resultado del \\(0\\%\\) como Rendimiento Logaritmico Total.</p>","tags":["Python","Estad\u00edstica"]},{"location":"finanzas-python/1-gestion-riesgo-portafolio/1-riesgo-retorno/#datos-ohclv","title":"Datos OHCLV","text":"<p>Este tipo de datos se presenta com\u00fanmente en el campo de finanzas, espec\u00edficamente en bolsa de valores, criptomonedas, etc. Estas siglas representan a Open, High, Close, Low, Volume:</p> <ul> <li>Open: Es el precio de apertura de un periodo determinado (como por a\u00f1o, semana, d\u00eda, 15min, 1min, etc.)</li> <li>High: Es el precio m\u00e1s alto alcanzado durante el periodo.</li> <li>Low: Es el precio m\u00e1s bajo que se alcanza durante el periodo.</li> <li>Close: Es el precio cuando se termin\u00f3 el periodo.</li> <li>Volume: Es el volumen de transacciones, n\u00famero total de unidades del activo que se negociaron durante el periodo seleccionado. Representa cuantas acciones, monedas o contratos cambiaron de mano durante el periodo.</li> </ul> <p>Gr\u00e1ficamente se utiliza en las Velas Japonesas, ya que estas contienen estos cincos t\u00e9rminos</p> Vela Japonesa <p>Adjusted Close</p> <p>El precio de cierre ajustado es el que se obtiene luego de realizar ajustes por:</p> <ul> <li>Dividendos</li> <li>Divisiones de acciones (Splits): Ocurre cuando el precio de una acci\u00f3n es muy alta y la empresa desea dividir para que sea m\u00e1s accesible a inversores minoristas.</li> <li>Otros eventos corporativos</li> </ul> <p>Este precio es con el que se debe realizar el an\u00e1lisis financiero y c\u00e1lculo de retornos</p> <p>Volumen</p> <p>La importancia del volumen radica en la Fuerza del movimiento del precio. Un precio que fluctua con alto volumen es m\u00e1s significativo que uno que cambia con bajo volumen.</p>","tags":["Python","Estad\u00edstica"]},{"location":"finanzas-python/1-gestion-riesgo-portafolio/1-riesgo-retorno/#ejemplos","title":"Ejemplos","text":"<p>Se estar\u00e1 trabajando con los siguientes datos:</p> Date Open High Low Close Volume Adjusted 2000-01-03 88.777 89.722 84.712 58.28125 53228400 38.527809 2000-01-04 85.893 88.588 84.901 56.31250 54119000 37.226345 2000-01-05 84.050 88.021 82.726 56.90625 64059600 37.618851 2000-01-06 84.853 86.130 81.970 55.00000 54976600 36.358688 2000-01-07 82.159 84.901 81.166 55.71875 62013600 36.833828 Rendimiento Discreto y Logaritmico Acumulado<pre><code>df = df.set_index(\"Date\")\ndf = df.sort_values(\"Date\") #(1)!\n\ndf[\"RC\"] = df[\"Adjusted\"].pct_change()\ndf[\"RC_Acumulativo\"] = (1 + df[\"RC\"]).cumprod() - 1 #(2)!\n\ndf[\"RL\"] = np.log(df[\"Adjusted\"]/df[\"Adjusted\"].shift(1)) \ndf[\"RL_Acumulativo\"] = df[\"RL\"].cumsum() #(3)!\n</code></pre> <ol> <li>Estos m\u00e9todos son importantes de aplicar desde un inicio cuando se quiere calcular los Retornos, colocar como \u00edndice a la columna <code>Date</code> y ordenarlo de forma ascendente respecto al \u00edndice.</li> <li> <ul> <li><code>.pct_change()</code>: Se utiliza para calcular el rendimiento discreto, en fracci\u00f3n no en %.</li> <li><code>.cumprod()</code> Se utiliza para calcular la suma acumulativa del producto del t\u00e9rmino que est\u00e1 a la izquierda.</li> </ul> </li> <li> <ul> <li><code>.shift(1)</code>: Es el logar\u00edtmo natural del precio actual y el precio anterior.</li> <li><code>.cumsum()</code>: Permite calcular la suma acumulativa.</li> </ul> </li> </ol> Adjusted RC RC_Acumulativo RL RL_Acumulativo 2000-01-03 38.527809 NaN NaN NaN NaN 2000-01-04 37.226345 -0.033780 -0.033780 -0.034364 -0.034364 2000-01-05 37.618851 0.010544 -0.023592 0.010489 -0.023875 2000-01-06 36.358688 -0.033498 -0.056300 -0.034072 -0.057947 2000-01-07 36.833828 0.013068 -0.043968 0.012983 -0.044964 ... ... ... ... ... ... 2018-02-12 88.713272 0.010773 1.302578 0.010716 0.834029 2018-02-13 89.410004 0.007854 1.320662 0.007823 0.841852 2018-02-14 90.809998 0.015658 1.356999 0.015537 0.857389 2018-02-15 92.660004 0.020372 1.405016 0.020168 0.877557 2018-02-16 92.000000 -0.007123 1.387886 -0.007148 0.870408","tags":["Python","Estad\u00edstica"]},{"location":"finanzas-python/1-gestion-riesgo-portafolio/1-riesgo-retorno/#distribucion","title":"Distribuci\u00f3n","text":"<p>Para poder entender la distribuci\u00f3n es importante saber 4 conceptos.</p> <ul> <li>Media (\\(\\mu\\)): Es el promedio de los datos</li> <li>Varianza (\\(\\sigma^2\\)): La variabilidad de los datos (\\(\\sigma\\) es la volatilidad)</li> <li>Asimetr\u00eda (Skewness): Es el sesgo que experimenta la distribuci\u00f3n</li> <li>Kurtosis: Es la relaci\u00f3n entre la altitud y la amplitud de la distribuci\u00f3n, ayuda a entendersi los datos son m\u00e1s o menos propensos a generar valores extremos.</li> </ul> <p>Teniendo en cuenta que la Distribuci\u00f3n Normal Est\u00e1ndar tiene las siguientes caracter\u00edsticas:</p> \\[\\mu=0, \\sigma^2=1, \\text{skewness}=0, \\text{kurtosis}=3 (\\text{exceso de kurtosis}=0)\\]","tags":["Python","Estad\u00edstica"]},{"location":"finanzas-python/1-gestion-riesgo-portafolio/1-riesgo-retorno/#media-y-varianza","title":"Media y Varianza","text":"<p>La importancia de la media radica en poder tener un solo valor que indica la estimaci\u00f3n de todo el conjunto de datos, as\u00ed poder realizar comparativas con otros activos.</p> <p>Calculando el retorno promedio diario podemos escalar para hallar el retorno promedio anual.</p> \\[RD_{anual}=(\\prod_{t=1}^{252}(1+RD_t))-1\\] \\[RL_{anual}=\\sum_{t=1}^{252}\\log{\\frac{P_t}{P_{t-1}}}\\] <p>De los datos hist\u00f3ricos, se puede calcular el rendimiento diario promedio, suponiendo que estos rendimientos promedio se da durante un a\u00f1o en condiciones similares.</p> \\[ \\begin{equation} \\bbox[3pt, border: 1pt solid #00adc3]{     RD_{anual}=(1+RD_{prom})^{252}-1     } \\label{eq:rd_anual} \\end{equation} \\] \\[ \\begin{equation} \\bbox[3pt, border: 1pt solid #00adc3]{     RL_{anual}=252*RL_{prom}     } \\label{eq:rl_anual} \\end{equation} \\] \\[ \\begin{equation} \\bbox[3pt, border: 1pt solid #00adc3]{     \\sigma_{anual}=\\sigma_{diaria}*\\sqrt{252}     } \\label{eq:varianza_anual} \\end{equation} \\] <p>Escalar anualmente</p> <p>Estos c\u00e1lculos no son para hacer una predicci\u00f3n para saber el retorno que se tendr\u00e1 en un nuevo a\u00f1o, dif\u00edcilmente se cumpla esto debido a otros los factores. Escalar anualmente respecto al promedio diario de los datos hist\u00f3ricos, nos permite poder comprarar el rendimiento un activo con otros.</p> Retorno Discreto y Logar\u00edtmica anual<pre><code># Retono Discreto promedio diario y anual\nRD_prom = np.mean(df[\"RC\"])\nRD_anual = (1+RD_prom)**252-1\n\n# Retorno Logaritmico promedio diario y anual\nRL_prom = np.mean(df[\"RL\"])\nRL_anual = 252*RL_prom\n\n# Desviaci\u00f3n est\u00e1ndar (volatilidad) diaria y anual\nsigma_diaria = np.std(df[\"RC\"])\nsigma_anual = sigma_diaria*np.sqrt(252)\n\n# Varianza diaria y anual\nvarianza = sigma_diaria**2\nsigma_anual = varianza**2\n</code></pre> RD RL Desv. Est\u00e1ndar Varianza Diaria 0.00037 0.00019 0.01934 0.00037 Anual 0.09985 0.04810 0.30703 0.09426 <p>En finanzas que una distribuci\u00f3n tenga un sesgo positivo es una buena se\u00f1al, ya que indicar\u00eda una mayor probabilidad de rendimientos altos.</p>","tags":["Python","Estad\u00edstica"]},{"location":"finanzas-python/1-gestion-riesgo-portafolio/1-riesgo-retorno/#skewness-asimetria","title":"Skewness (Asimetr\u00eda)","text":"<p>Una \\(\\text{asimetr\u00eda} &gt; 0\\), indica una falta de normalizaci\u00f3n, y que est\u00e1s sesgado a la derecha. Es muy importante saber si la distribuci\u00f3n de los datos no est\u00e1 normalizado ya que cuando se quiera hacer un modelo de predicci\u00f3n, la normalizaci\u00f3n puede ser un requisito.</p> <p>Una \\(\\text{asimetr\u00eda} &lt; 0\\), indica falta de normalizaci\u00f3n y que est\u00e1 sesgado a la izquierda, es decir, hay mayor probabilidad de un rendimiento negativo de alto impacto.</p>","tags":["Python","Estad\u00edstica"]},{"location":"finanzas-python/1-gestion-riesgo-portafolio/1-riesgo-retorno/#kurtosis","title":"Kurtosis","text":"<p>El kurtosis mide la forma de las colas, indica qu\u00e9 tan propensa es una distribuci\u00f3n a generar eventos extremos. En finanzas, un alto exceso de kurtosis indica un alto riesgo de eventos extremos (grandes p\u00e9rdidas o ganancias).</p> <p>Si se utiliza la biblioteca <code>scipy</code> se debe tener en cuenta que no se calculo el kurtosis en s\u00ed, sino que se calcula el exceso de kurosis. Se sabe que en una distribuci\u00f3n normal el kurtosis = 3, un valor m\u00e1s alto o m\u00e1s bajo, se le denomina exceso de kurtosis. Por lo tanto, en <code>scipy</code> si el exceso de kurtosis es igual 0, estar\u00edamos hablando posiblemente de una distribuci\u00f3n normal (esto es porque resta 0 al kurtosis para hallar el exceso de kurtosis), si en caso queremos hallar el kurtosis simple, debemos sumar +3 al exceso arrojado por <code>scipy</code>.</p> <p>Es muy importante que no haya valores nulos a la hora de calcular la asimetr\u00eda y el kurtosis.</p> Exceso de Kurtosis<pre><code>from scipy.stats import skew, kurtosis\n\ndf_clean = df[\"RC\"].dropna()\n\nprint(\"asimetr\u00eda: \",skew(df_clean))\n\nexceso_kurtosis=kurtosis(df_clean)\nprint(\"Exceso de kurtosis: \",exceso_kurtosis)\nprint(\"Kurtosis: \", exceso_kurtosis+3)\n</code></pre> Medida Valor asimetr\u00eda 0.21935 Exceso de kurtosis 10.31457 kurtosis 13.31457 <p>Hasta ahora hemos visto 4 caracter\u00edsticas que nos ayuda a tener una idea acerca de la distribuci\u00f3n de nuestros datos, sin embargo, estos no son suficientes para estar seguros que tenemos una distribuci\u00f3n normal (m\u00e1s cuando el skewness y kurtosis son aproximaciones). Lo que nos podr\u00eda ayudar a estar seguro de tener una distribuci\u00f3n normal son:</p> <ul> <li>Histogramas y gr\u00e1ficos de densidad</li> <li>QQPlot (Quantile-Quantile Plot)</li> <li>Pruebas de normalidad<ul> <li>Shapiro-Wilk test</li> <li>Kolmogorov-Smirnov test</li> <li>Anderson-Darling test</li> <li>Jarque-Bera test</li> </ul> </li> </ul> <p>El uso de las histogramas m\u00e1s pruebas estad\u00edsticas es buena para tener una confirmaci\u00f3n robusta, tambi\u00e9n est\u00e1 la opci\u00f3n de QQPlot o Jarque-Bera test para conjuntos de datos grandes.</p>","tags":["Python","Estad\u00edstica"]},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/","title":"Portafolio de Inversi\u00f3n","text":""},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#portafolio-y-backtesting","title":"Portafolio y Backtesting","text":"<p>El portafolio (cartera) es un conjunto de activos financieros de diferentes empresas que puede tener un inversionista, pueden ser:</p> <ul> <li>Acciones</li> <li>Bonos</li> <li>Fondos de inversi\u00f3n</li> <li>Criptomonedas</li> <li>Divisas</li> <li>Bienes ra\u00edces</li> </ul> <p>El objetivo de una cartera es poder maximizar las ganancias y minimizar el riesgo. Se gestiona a trav\u00e9s de diversificaci\u00f3n, que consiste en invertir en varios activos para reducir la exposici\u00f3n a p\u00e9rdidas significativas.</p>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#backtesting","title":"Backtesting","text":"<p>El Backtesting es una t\u00e9cnica que se utiliza para probar la efectividad de una estrategia de inversi\u00f3n, simulando c\u00f3mo habr\u00eda funcionado en el pasado.</p> <ul> <li>Se define la estrategia de inversi\u00f3n</li> <li>Se aplican los datos hist\u00f3ricos del mercado</li> <li>Se analizan los resultados<ul> <li>Rendimiento potencial</li> <li>Riesgo</li> <li>Rentabilidad ajustada al riesgo</li> </ul> </li> </ul>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#pesos","title":"Pesos","text":"<p>En un portalio al haber varios activos financieros, es importante saber cu\u00e1l es el peso de cada uno, su c\u00e1lculo no es m\u00e1s que la proporci\u00f3n que tiene un activo con el total de los activos. Por ejemplo, si tiene dos acciones, uno $/. 5000.00 en <code>AAPL</code> y $/. 3000.00 <code>MSFT</code>, entonces el peso de <code>APPL</code> es 0.625 y de <code>MSFT</code> es 0.375.</p> <p>Es importante saber el peso de cada activo de nuestra cartera, ya que este nos ayuda a controlar el riesgo que se est\u00e1 asumiendo en cada tipo de activo. Mediante los pesos podemos realizar un Rebalanceo; por ejemplo, si tenemos un activo con un peso de 50% a 70%, entonces debemos de mover nuestro capital de este activo, ya que en caso de haber una ca\u00edda significativa en ese activo, nos perjudicar\u00eda en gran medida.</p>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#ejemplo","title":"Ejemplo","text":"<p>Se trabajar\u00e1 con los siguientes datos:</p> Date AAPL MSFT XOM JNJ JPM AMZN GE FB T 2017-01-03 0.002849 0.007081 0.006980 0.005468 0.010894 0.005068 0.002848 0.015732 0.011521 2017-01-04 -0.001119 -0.004474 -0.011002 -0.001640 0.001844 0.004657 0.000316 0.015660 -0.005811 2017-01-05 0.005085 0.000000 -0.014907 0.010463 -0.009205 0.030732 -0.005678 0.016682 -0.002806 2017-01-06 0.011148 0.008668 -0.000565 -0.004792 0.000116 0.019912 0.002855 0.022707 -0.019924 2017-01-09 0.009159 -0.003183 -0.016497 -0.000172 0.000697 0.001168 -0.004745 0.012074 -0.012585 Company Name Ticker Portfolio Weight Apple AAPL 12% Microsoft MSFT 15% Exxon Mobil XOM 8% Johnson &amp; Johnson JNJ 5% JP Morgan JPM 9% Amazon AMZN 10% General Electric GE 11% Facebook FB 14% AT&amp;T T 16% Rendimiento Acumulado<pre><code>portafolio = portafolio.sort_values(\"Date\")\nportafolio=portafolio.set_index(\"Date\") #(1)!\n\npesos_portafolio=[0.12, 0.15, 0.08, 0.05, 0.09, 0.10, 0.11, 0.14, 0.16]\n\nRendimientoPeso = portafolio @ pesos_portafolio #(2)!\n\nportafolio[\"Rendimiento\"]=RendimientoPeso\n\nRendimientoAculativo = (1+RendimientoPeso).cumprod()-1 #(3)!\n\nRendimientoAculativo.plot()\n</code></pre> <ol> <li>Como se indic\u00f3 en el cap\u00edtulo anterior, tenemos que tener como \u00edndice a la columna fecha y que est\u00e9 ordenada ascendentemente.</li> <li>El operador <code>@</code> permite la multiplicaci\u00f3n de matrices o arrays, entrega un solo valor por cada fila. Multiplica el peso por el rendimiento que se tuvo en el d\u00eda, suma cada uno de los resultados de cada activo y nos entrega un rendimiento diario de la cartera.</li> <li>Esto se vi\u00f3 en el cap\u00edtulo anterior, es el c\u00e1lculo del rendimiento discreto acumulativo.</li> </ol> Rendimiento por Peso <p>Qu\u00e9 hubiera pasado si solo hubieramos invertido en un solo activo</p> Retorno Unitario <p>Efecto de los pesos en nuestro portafolio</p> <p>Tener una cartera balanceada nos ayuda a disminuir el riesgo de perder todo, esto tambi\u00e9n afecta al beneficio, si tenemos un monto peque\u00f1o en una activo y este activo crece dr\u00e1sticamente, su impacto en nuestra cartera ser\u00e1 poca ya que tenemos muy poco capital en este activo, pero esto tambi\u00e9n nos beneficia en caso que un activo cae dr\u00e1sticamente. En esta \u00faltima imagen podemos ver c\u00f3mo empresa como Apple y Amazon tuvieron un beneficio alrededor del 50%, pero tambi\u00e9n empresas como General Electric tuvieron una gran ca\u00edda, si solo hubieramos invertido en esta empresa hubieramos tenido una p\u00e9rdida del 42%.</p>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#pesos-iguales-como-referencia","title":"Pesos iguales como referencia","text":"<p>Una de las formas que podemos comparar nuestra estrategia, es compararlo con una estrategia donde la cartera tiene un pesos igual para todos los activos, veamos c\u00f3mo ser\u00eda.</p> Rendimiento Igual<pre><code>pesos_iguales=np.repeat(1/9, 9) #(1)!\nportafolio[\"RendimientoEW\"]=portafolio.iloc[:,:9] @ pesos_iguales #(2)!\n\ndef cumulative_returns_plot(df, columnas=None):\n    df2=pd.DataFrame()\n    if columnas is None:\n        columnas=df.columns\n    for col in columnas:\n        df2[col]=(1+df[col]).cumprod()-1\n    sns.lineplot(df2) #(3)!\n\ncumulative_returns_plot(portafolio, \"Rendimiento\", \"RendimientoEW\") #(4)!\n</code></pre> <ol> <li>Creamos una array con 9 elementos del mismo valor (1/9), estos ser\u00edan los pesos de nuestro portafolio.</li> <li>Seleccionamos las primeras 9 columnas con todas sus filas para realizar el c\u00e1lculo del nuevo rendimiento, hay que tener en cuenta que hay una nueva columna que es <code>Rendimiento</code> que se calcul\u00f3 en el ejemplo de arriba.</li> <li>Creamos una funci\u00f3n que nos permite graficar las columnas.</li> <li>Utilizando la funci\u00f3n que hemos creado, graficamos ambos rendimientos.</li> </ol> Rendimiento con Pesos iguales"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#portafolios-ponderadas-por-capitalizacion-de-mercado","title":"Portafolios ponderadas por capitalizaci\u00f3n de mercado","text":"<p>Una estrategia muy utilizada es que los pesos no lo determinemos nosotros, sino que sea proporcial a la capitalizaci\u00f3n de cada empresa. Esta misma estrategia lo utiliza el indicador S&amp;P 500.</p> Company Name Ticker Market Cap ($ Billions) Apple AAPL 601.51 Microsoft MSFT 469.25 Exxon Mobil XOM 349.50 Johnson &amp; Johnson JNJ 310.48 JP Morgan JPM 299.77 Amazon AMZN 356.94 General Electric GE 268.88 Facebook FB 331.57 AT&amp;T T 246.09 Rendimiento Capitalizaci\u00f3n del Mercado<pre><code>market_capitalizations = np.array([601.51, 469.25, 349.5, 310.48, 299.77,\n                                   356.94, 268.88, 331.57, 246.09]) #(1)!\n\nmcap_weights = market_capitalizations/market_capitalizations.sum() #(2)!\n\nportafolio[\"Rendimiento_MCap\"] = portafolio.iloc[:,:9] @ mcap_weights\n\ncumulative_returns_plot(portafolio, \"Rendimiento\", \"RendimientoEW\",\n                        \"Rendimiento_MCap\")\n</code></pre> <ol> <li>Creamos nuestro array con la capitlizaci\u00f3n de mercado de cada empresa</li> <li>Ponderamos los valores, respecto al total.</li> </ol> Rendimiento Pesos por Market Capital <p>Resumen</p> <p>Podemos ver que en este caso la mejor opci\u00f3n es la ponderaci\u00f3n respecto a la capitalizaci\u00f3n de mercado de cada activo, una de sus desventajas de usar esta estrategia es que nuestro portafolio estar\u00e1 muy influenciado por las grandes empresas, estando desbalanceado. Sin embargo, es una estrategia que tiene buenos retornos y sabiendo que es utilizada por muchos indicarodores con buenos rendimientos, es una buena elecci\u00f3n.</p>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#correlacion-y-covarianza","title":"Correlaci\u00f3n y Covarianza","text":"<p>La covarianza mide si dos variables tienen el mismo sentido o direcci\u00f3n, es decir, si una variable aumenta, la otra tambi\u00e9n aumentar\u00e1, o si uno aumenta la otra disminuir\u00e1 (diferente direcci\u00f3n). Veamos:</p> <ul> <li>Covarianza positiva: Las variables se mueven en la misma direcci\u00f3n.</li> <li>Covarianza negativa: Las variables se mueven en direcci\u00f3n opuesta.</li> </ul> <p>Sin embargo, la covarianza por s\u00ed sola no nos indica qu\u00e9 tan relacionada est\u00e1n ambas variables, aqu\u00ed entra en juego la Correlaci\u00f3n de Pearson, que no es m\u00e1s que la normalizaci\u00f3n de la covarianza.</p> <ul> <li>Correlaci\u00f3n -&gt; +1: Alta relaci\u00f3n, se mueven en la misma direcci\u00f3n.</li> <li>Correlaci\u00f3n -&gt; 0: Sin relaci\u00f3n.</li> <li>Correlaci\u00f3n -&gt; -1: Alta relaci\u00f3n opuesta, se mueven de direcci\u00f3n contraria.</li> </ul> <p>En el \u00e1mbito financiero, la alta correlaci\u00f3n positiva en activos no es una buena se\u00f1al para nuestro portafolio, esto es debido a que si por algun contexto pol\u00edtico, social o econ\u00f3mico, hay una ca\u00edda en nuestro activo, al estar todas relacionadas (en el mismo sentido) entonces todos nuestros rendimientos caer\u00e1. Por tal motivo, se recomienda tener carteras diversificadas y para esto nos ayudar\u00e1 la correlaci\u00f3n.</p> <p>Veamos el caso del \u00edndice burs\u00e1til S&amp;P 500, tiene las 500 empresas m\u00e1s grandes de los EE.UU respecto a su capitalizaci\u00f3n en el mercado, donde hay empresas de varios rubros (diversificado), tecnol\u00f3gicas, energ\u00e9ticas, inmobiliarias, salud, financiero, etc. Este \u00edndice es robusto y se demuestra viendo c\u00f3mo ha ido durante toda su historia, teniendo un rendimiento promedio anual de \\(10.50\\%\\) y de los \u00faltimos 5 a\u00f1os fue de \\(9.4\\%\\).</p> <p>Por otro lado, tenemos el caso del \u00edndice burs\u00e1til NASDAQ-100, tiene a las 100 empresas m\u00e1s grandes de los EEUU, respecto a su capitalizaci\u00f3n en el mercado, solo del sector tecnol\u00f3gico. Si bien la teor\u00eda nos dice que no es bueno que los activos de nuestra cartera tenga alta correlaci\u00f3n, este \u00edndice nos muestra que a\u00fan as\u00ed se puede llegar a tener un gran rendimiento. Este \u00edndice tuvo un redimiento promedio anual en toda su historia de \\(12\\% a 13\\%\\) y en los \u00faltimos 5 a\u00f1os un \\(17 \\%\\). Quiz\u00e1s pensemos que considerar la correlaci\u00f3n ya no es una buena medida para medir nuestra estrategia, pero este es un caso muy especial, ya que las empresas que componen a este \u00edndice son muy inovadoras, y est\u00e1n en constante desarrollo y adaptabilidad. Veamos su rendimiento desde el a\u00f1o 2017</p> A\u00f1o S&amp;P 500 Nasdaq-100 2018 -4.4% -1.0% 2019 +31.5% +38.0% 2020 +18.4% +47.6% 2021 +26.9% +26.6% 2022 -19.4% -33.1% 2023 +22.4% +55.0% 2024 +23.3% +24.8% <p>Como se puede ver, el rendimiento del \u00edndice NASDAQ-100 es mayor en promedio que el \u00edndice S&amp;P 500, sin embargo, podemos ver que en el a\u00f1o 2022 tuvo una gran ca\u00edda (\\(-33.1 \\%\\)) que m\u00e1s que del S&amp;P 500, en ese a\u00f1o por diversos motivo el rubro tecnol\u00f3gico tuvo una gran ca\u00edda, por lo tanto NASDAQ-100 se vio gravemente afectado, el S&amp;P 500 tambi\u00e9n sufri\u00f3 este golpe ya que cerca del \\(28\\%\\) est\u00e1 invertida en tecnolog\u00eda.</p> <p>Para ver la volatilidad del portafolio (\\(\\sigma_{portafolio}\\)) se requiere conocer el peso y covarianza.</p> \\[ \\begin{equation} \\bbox[3pt, border: 1pt solid #00adc3]{\\sigma_{portafolio} = \\sqrt{w_T \\cdot \\sum \\cdot w}} \\label{eq:volat_portafolio} \\end{equation} \\] <p>Donde,</p> <ul> <li>\\(\\sigma_{portafolio}\\): Volatilidad del portafolio.</li> <li>\\(\\sum\\): Matriz de covarianza de retornos.</li> <li>\\(w\\): Matriz de pesos del portafolio (\\(w_T\\) es la transposici\u00f3n de la matriz de peso).</li> <li>\\(\\cdot\\) : Operador multiplicaci\u00f3n punto.</li> </ul> <p>Esta f\u00f3rmula es una representaci\u00f3n matricial de la volatilidad de un portafolio, es una gran ventaja para operaciones computacionales.</p>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#ejemplo_1","title":"Ejemplo","text":"Correlaci\u00f3n<pre><code>df_corr = portafolio.iloc[:,:9].corr() #(1)!\n\nsns.heatmap(df_corr, , annot=True, cmap=\"YlGnBu\", linewidths=0.3, \n            annot_kws={\"size\": 8}) #(2)!\n\nplt.xticks(rotation=90)\nplt.yticks(rotation=0); #(3)!\n</code></pre> <ol> <li>Solo tomamos los datos de los rendimientos diarios de los activos.</li> <li>Creamos nuestro mapa de calor<ul> <li><code>df_corr</code>: El dataframe que contiene la correlaci\u00f3n.</li> <li><code>annot=True</code>: Para que se muestre los valores en los cuadros.</li> <li><code>cmpa=\"YlGnBu\"</code>: Paleta de color.</li> <li><code>linewidths=0.3,</code>: Tama\u00f1o de la l\u00ednea que separa a cada cuadro.</li> <li><code>annot_kws={\"size\": 8}</code>: Tama\u00f1o de los n\u00fameros en el cuadro.</li> </ul> </li> <li>Rotamos el texto del <code>eje X</code> a 90\u00b0, y del <code>eje Y</code> lo colocamos a 0\u00b0.</li> </ol> Correlaci\u00f3n de Portafolio <p>Conclusi\u00f3n del mapa de calor</p> <p>Podemos ver que tenemos activos que est\u00e1n relacionadas, como <code>APPL</code>, <code>MSFT</code>, <code>FB</code> en su mayor\u00eda superan el \\(0.50\\), esto es de esperarse sabiendo que estas empresas son tecnol\u00f3gicas. Tambi\u00e9n tenemos activos sin relaci\u00f3n entre ellas y otras que est\u00e1n ligeranmente (muy poco) relacionadas en direcci\u00f3n opuesta.</p> Volatilidad<pre><code>df_cov = portafolio.iloc[:,:9].cov()\ndf_cov_anual = df_cov*252 # 252 d\u00edas h\u00e1biles de comercio en un a\u00f1o\n\nportfolio_volatility = np.sqrt(np.dot(pesos_portafolio.T,\n                                      np.dot(df_cov_anual, pesos_portafolio)))\nprint(portfolio_volatility) # 8.93%\n</code></pre> <p>Para tener una idea de qu\u00e9 tan vol\u00e1til es nuestra cartera, veamos el siguiente cuadro</p> Volatilidad Anual (%) Nivel de Volatilidad Ejemplos de Activos/Portafolios 0-5% Muy baja Bonos del Tesoro, cuentas de ahorro 5-10% Baja Portafolios diversificados conservadores 10-20% Moderada S&amp;P 500, portafolios balanceados 20-30% Alta Nasdaq-100, acciones tecnol\u00f3gicas 30% o m\u00e1s Muy alta (extrema) Criptomonedas, startups, portafolios especulativos <p>Conclusiones</p> <p>De acuerdo al cuadro de volatilidad, nuestra cartera tiene una volatiliad baja, esto implicar\u00eda un menor riesgo a p\u00e9rdidas, pero a su vez ganancias no tan grandes como otras. Aunque hemos visto que el rendimiento durante el a\u00f1o 2017 fue cerca del \\(20\\%\\), lo cu\u00e1l lo hace muy buena estrategia. Faltar\u00eda realizar la prueba a nivel hist\u00f3rico c\u00f3mo se hubiese comportado esta cartera.</p>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#portafolio-de-markowitz","title":"Portafolio de Markowitz","text":"<p>Imaginemos que de nuestros 9 activos hemos creado \\(100,000\\) diferentes carteras, cada una con un peso diferente y queremos saber cu\u00e1l de todas las carteras es la mejor en relaci\u00f3n riesgo-rentabilidad.</p> \\[ \\begin{equation} \\bbox[3pt, border: 1pt solid #00adc3]{S=\\frac{R_a-r_f}{\\sigma_a}} \\label{eq:markowitz} \\end{equation} \\] <p>Donde,</p> <ul> <li>\\(S\\): \u00cdndice de Sharpe (Sharpe Ratio).</li> <li>\\(R_a\\): Rendimiento esperado. Es el retorno promedio de la inversi\u00f3n durante un periodo de tiempo, se expresa en porcentaje.</li> <li>\\(r_f\\): Rendimiento libre de riesgo. Suelen ser los bonos del gobierno, donde su tasa de riesgo es cercano a cero.</li> <li>\\(\\sigma_a\\): Desviaci\u00f3n est\u00e1ndar o volatilidad, se calcula usando retornos hist\u00f3ricos.</li> </ul> <p>Nos permite comparar el rendimiento de diferentes carteras por cada unidad de incremento de riesgo.</p> <ul> <li>\\(S&lt;0\\): La inversi\u00f3n tiene un desempe\u00f1o peor que \\(r_f\\).</li> <li>\\(0&lt;S&lt;1\\): Inversi\u00f3n sub\u00f3ptima.</li> <li>\\(1&lt;S&lt;2\\): Inversi\u00f3n buena.</li> <li>\\(3&lt;S\\): Inversi\u00f3n excelente (poco com\u00fan).</li> </ul>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#frontera-eficiente-de-markowitz","title":"Frontera eficiente de Markowitz","text":"<p>Son las carteras que son las \u00f3ptimas en relaci\u00f3n rendimiento-riesgo. Todo portofolio que se encuentre en la frontera son las m\u00e1s eficiente, ya que no hay forma de mejorar el rendimiento sin asumir riesgo, las carteras que est\u00e1n debajo son ineficiente, porque con un mismo nivel de riesgo se obtiene un rendimiento menor.</p> <p>Esto se obtiene despu\u00e9s de realizar un an\u00e1lisis a nivel hit\u00f3rico de todas las combinaciones posibles de los pesos de cada activo, m\u00e1s no es una predicci\u00f3n.</p> <p> Frontera de eficiencia <ul> <li> <p>Max Shape Ratio (MSR) Es el portafolio con el m\u00e1ximo \u00edndice de Shape, es el punto de tangencia entre la frontera de eficiencia y el Capitla Market Line (teor\u00eda de CAPM):</p> </li> <li> <p>Global Minimum Volatility (GMV): Es el portafolio con la volatilidad m\u00ednima.</p> </li> <li>\\(R_f\\): Es el punto donde no hay riesgo (Risk Free)</li> </ul> <p>MSR vs GSM</p> <p>Si bien el MSR es el que brinda un mayor retorno por el riesgo tomado, suele ser m\u00e1s inconsistente que el GSM, esto es debido a que cuando lo aplicamos en la actuliadad los resultados var\u00edan mucho, debido a los m\u00faltiples factores del mercado, siendo el GSM m\u00e1s \"conservadora\" debido al poco riesgo que se toma, pero obtiendo un buen retorno.</p>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/2-portafolio/#ejemplos","title":"Ejemplos","text":"<p>Hemos creado una lista random de pesos para cada activo de nuestro portafolio, se muestra el datafram <code>pesos_aleatorios</code>:</p> AAPL weight MSFT weight XOM weight JNJ weight JPM weight AMZN weight GE weight FB weight T weight Returns Volatility 0.000053 0.263110 0.007022 0.040087 0.000027 0.024316 0.355899 0.299400 0.010087 0.127453 0.171565 0.042360 0.034922 0.079355 0.043057 0.001435 0.202032 0.225924 0.362324 0.008590 0.138614 0.182723 0.207824 0.002132 0.005982 0.041657 0.007498 0.406642 0.064929 0.229260 0.034075 0.155952 0.201185 0.096565 0.016775 0.118409 0.037725 0.020013 0.045195 0.512282 0.153015 0.000020 0.118787 0.148958 0.131309 0.002733 0.002360 0.047573 0.050633 0.289410 0.313717 0.157123 0.005141 0.138304 0.171473 Portafolio MSR<pre><code>risk_free = 0 # Asumamos que es 0\npesos_aleatorios[\"Sharpe\"]=(pesos_aleatorios[\"Returns\"] - risk_free) / \n                            pesos_aleatorios[\"Volatility\"] \n                           ) #(1)!\n\npeso_sharpe=pesos_aleatorios[\n                pesos_aleatorios[\"Sharpe\"] == \n                pesos_aleatorios[\"Sharpe\"].max()\n                ] #(2)!\n\nmsr_pesos=peso_sharpe.iloc[0, :9] #(3)!\n\nportafolio[\"RendimientoMSR\"]=portafolio.iloc[:, :9] @ np.array(msr_pesos) #(4)!\n\ncumulative_returns_plot(portafolio,\n                columas=[\"Rendimiento_MCap\", \"RendimientoEW\", \"RendimientoMSR\"]\n                ) #(5)!\n</code></pre> <ol> <li>Se calcula los \u00edndices de Sharpe, mediante la f\u00f3rmula mostrada.</li> <li>Se obtiene la fila donde se est\u00e1 el \u00edndice de shape m\u00e1ximo.</li> <li>Se escoge solo los pesos del \u00edndice de Shape Ratio m\u00e1ximo (MSR).</li> <li>Se realiza el c\u00e1lculo del rendimiento, producto matricial entre los activos del portafolio y la matriz de los pesos.</li> <li>Se grafica los tres rendimientos.</li> </ol> Retorno acumulado del MSR <p>Conclusi\u00f3n</p> <p>Se puede ver en el gr\u00e1fico que a\u00fan eligiendo la cartera con mayor Sharpe Ratio (MSR) nuestro rendimiento no es muy bueno, incluso es menor a la media, esto es porque los datos con que se trabaj\u00f3 fueron datos hist\u00f3ricos y ahora se prob\u00f3 con datos \"actuales\", demostrando que el Sharpe Ratio no es una predicci\u00f3n sino una medida de comparativa.</p> <p>Desafortunadamente, la cartera MSR suele ser bastante err\u00e1tica. Aunque la cartera haya tenido un ratio de Sharpe hist\u00f3rico alto, eso no garantiza que la cartera tenga un buen ratio de Sharpe en el futuro.</p> Portafolio GMV<pre><code>gmv_pesos=pesos_aleatorios.sort_values(\n                            'Volatility', ascending=True\n                            ).iloc[0, :9] #(1)!\n\nportafolio[\"RendimientoGMV\"] = portafolio.iloc[:, :9] @ np.array(gmv_pesos) #(2)!\n\ncumulative_returns_plot(portafolio, \n            columns=[\"Rendimiento_MCap\", \"RendimientoEW\", \n            \"RendimientoMSR\", \"RendimientoGMV\"])\n</code></pre> <ol> <li>Se ordena respecto a la columna <code>Volatility</code> y tomamos los pesos la primera fila, esta es la que tiene la volatilidad m\u00e1s baja de todas.</li> <li>Se calcula el rendimiento respecto a los pesos del GMV.</li> </ol> Retorno acumulado del GMV <p>Conclusi\u00f3n</p> <p>Podemos ver c\u00f3mo la gr\u00e1fica de la cartera GMV si bien tiene un retorno menor al MSR, se puede rescatar que no fluctua tan dr\u00e1sticamente como su contraparte, obtieniendo un rendimiento alrededor del \\(10\\%\\) y sin correr mucho riesgo. A\u00fan as\u00ed, sigue siendo menor a una estrategia simple como es el <code>RendimientoEW</code> (todos los pesos son iguales).</p>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/3-factor-investing/","title":"Inversi\u00f3n Factorial","text":""},{"location":"finanzas-python/1-gestion-riesgo-portafolio/3-factor-investing/#analisis-factorial","title":"An\u00e1lisis Factorial","text":"<p>El an\u00e1lisis factorial es la indentificaci\u00f3n de los factores econ\u00f3micos que explican las variaciones en los rendiminetos de los activos financieros (acciones, portafolios, etc.).</p> <p>Permite entender c\u00f3mo los distintos factores de riesgos (tasa de inter\u00e9s, inflaci\u00f3n, desempleo, crecimiento econ\u00f3mico, etc.) influyen en el comportamiento de los activos o carteras de inversi\u00f3n. Para qu\u00e9 nos siver el an\u00e1lisis factorial</p> <ul> <li>Identificar los fatores  que afectan a los activos o sectores econ\u00f3micos.</li> <li>Identificar factores claves que pueden influir en los rendimientos futuros, permitiendo hacer una predicci\u00f3n de los retornos.</li> </ul> <p>Tipos de factores en los distintos niveles:</p> Macroecon\u00f3micos Mercado Empresa Inflaci\u00f3n \u00cdndices burs\u00e1tiles Tama\u00f1o de la empresa Tasa de inter\u00e9s Tipos de cambio Relaci\u00f3n precio/valor contable PBI Precios de commodities <sup>1</sup> Momentum <sup>2</sup> Desempleo"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/3-factor-investing/#modelos-de-valoracion-de-activos","title":"Modelos de valoraci\u00f3n de activos","text":"<p>Son modelos que ayudan a estimar el valor o retorno esperado de una inversi\u00f3n, considerando los factores de riesgo que afectan su rendimiento.</p> <ul> <li>CAPM</li> <li>Modelo Fama-French (3 factores)</li> <li>APT (Arbitrage Pricing Theory)</li> </ul>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/3-factor-investing/#capital-asset-pricing-model-capm","title":"CAPITAL ASSET PRICING MODEL (CAPM)","text":"<p>Es una herramienta financiera que ayuda a calcular la rentabilidad esperada de un activo financiero, entorno al riesgo que conlleva el activo.</p> <p>El CAPM permite:</p> <ul> <li>Calcular el rendimiento esperado de una inversi\u00f3n.</li> <li>Determinar si un activo est\u00e1 sobrevalorado o infravalorado</li> <li>Ayuda a decidir qu\u00e9 activos a\u00f1adir a la cartera</li> </ul> \\[E(R_i) = R_f + \\beta_i*(E(R_m)-R_f)\\] <p>Donde,</p> <ul> <li>\\(E(R_i)\\): Rentabilidad esperada del activo \\(i\\) (acci\u00f3n en espec\u00edfico, no de toda la inversi\u00f3n).</li> <li>\\(R_f\\): Tasa de retorno de libre riesgo (bonos del gobierno).</li> <li>\\(\\beta_i\\): Mide c\u00f3mo se mueve este activo en espec\u00edfico en relaci\u00f3n al mercado.</li> <li>\\(E(R_m)\\): Rentabilidad del mercado.</li> </ul>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/3-factor-investing/#Exceso-rendimiento","title":"Exceso de rendimiento","text":"<p>Es el rendimiento de una inversi\u00f3n que supera el rendimiento de un activo libre de riesgo; es decir, es la diferencia entre un rendimiento de un activo (acci\u00f3n o cartera) y el rendimiento de una inversi\u00f3n libre de riesgo (bonos de gobierno).</p> \\[\\text{Exceso de Retorno} = \\underbrace{R_i}_{\\text{rendimiento de la inversi\u00f3n}} - \\overbrace{R_f}^{\\text{rendimiento libre de riesgo}}\\] <p>Supongamos que en un pa\u00eds el retorno o tasa de inter\u00e9s al invertir en un bono del gobierno o dep\u00f3sito en el banco es del \\(10\\%\\), este ser\u00eda el retorno libre de riesgo, pero hemos decidido invertir en acciones, durante un a\u00f1o nuestro retorno fue del \\(8\\%\\), entonces:</p> \\[\\text{Exceso de Retorno} = 8\\% - 10\\% = -2\\%\\] <p>El rendimiento fue menor por invertir en una cartera, en vez de invertir en un activo seguro.</p> <p>De la f\u00f3rmula del CAPM, ahora podemos verlo de otra forma</p> \\[\\underbrace{E(R_i) - R_f}_{\\text{Exceso de retorno del activo}} = \\beta_i*\\underbrace{(E(R_m)-R_f)}_{\\text{Exceso de retorno del mercado}}\\] <ul> <li>\\(\\beta_i\\): Coeficiente que relaciona el cambio del exceso del activo respecto al cambio del exceso de retorno del mercado</li> </ul> <p>Ejemplo del \\(\\beta_i\\)</p> <p>Si el \\(\\beta_i = 1.5\\) significa que, si el mercado sube un \\(10\\%\\), entonces se espera que el rendimiento del activo suba un \\(15\\%\\). Si el mercado tiene una ca\u00edda del \\(10\\%\\), se espera que la acci\u00f3n baje un \\(15\\%\\)</p> <p>Otra forma de ver la ecuaci\u00f3n es mediante una regresi\u00f3n lineal simple:</p> \\[\\underbrace{E(R_i)}_{y} = \\underbrace{\\beta_i}_{m}*\\underbrace{(E(R_m)-R_f)}_{\\Delta x} + \\underbrace{R_f}_{b}\\] <p>El \\(\\beta_i\\) ser\u00eda la pendiente de la recta y como sesabe, la pendiente indica la cantidad de cambio en la variable independiente (\\(y\\)) por cada unidad de cambio en la variable independiente (\\(E(R_m)-R_f\\))</p> <ul> <li>\\(\\beta &gt; 1\\): El activo es m\u00e1s volatil que el mercado. Las acciones de empresas tecnol\u00f3gicas entran en caso, por tal motivo sus rendimientos suelen ser de alto impacto.</li> <li>\\(\\beta &lt; 1\\): El activo es menos volatil que el mercado. Los bonos del gobierno o acciones de empresas consolidadas y estables.</li> <li>\\(\\beta = 1\\): El activo tiene una relaci\u00f3n directa con el mercado. El \u00edndice bus\u00e1til S&amp;P 500 tiene un \\(\\beta \\approx 1\\).</li> <li>\\(\\beta &lt; 0\\): El activo se mueve en direcci\u00f3n opuesta al mercado. Activos como el oro o los bonos del gobierno, ya que tienden a subir cuando los mercados burs\u00e1tiles caen.</li> </ul>"},{"location":"finanzas-python/1-gestion-riesgo-portafolio/3-factor-investing/#relacion-entre-capm-y-sharpe-ratio-a-traves-de-la-recta-cml","title":"Relaci\u00f3n entre CAPM y Sharpe Ratio a trav\u00e9s de la recta CML","text":"<ul> <li>[Frontera de Eficiencia]</li> </ul> <ol> <li> <p>Son las materias primas que se pueden comprar, vender o comercializar, y que se utilizan para fabricar otros bienes y servicios.\u00a0\u21a9</p> </li> <li> <p>Mide la velocidad de cambio del precio de un activo en un periodo determinado. Se basa en la idea de que los activos que han tenido buen rendimiento reciente seguir\u00e1n subiendo, y los que han tenido mal rendimiento continuar\u00e1n cayendo, al menos a corto plazo.</p> <ul> <li>Si un activo subi\u00f3 mucho recientemente, es probable que siga subiendo.</li> <li>Si un activo cay\u00f3 mucho recientemente, es probable que siga cayendo. \u2192</li> </ul> <p>\u21a9</p> </li> </ol>"}]}